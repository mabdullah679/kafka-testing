-e \n\n===== ./redeploy.sh =====\n
#!/bin/bash
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "$0")" && pwd)"
cd "$PROJECT_ROOT" || exit 1

TEMP_LOG="$PROJECT_ROOT/redeploy_temp.log"
: > "$TEMP_LOG"  # Clear the log at the very start

sleep_and_echo() {
  echo -e "$1"
  sleep 1
}

log_and_fail() {
  echo "‚ùå $1"
  echo "üìÑ See full logs here: $TEMP_LOG"
  exit 1
}

sleep_and_echo "üìÅ Starting redeployment from: $PROJECT_ROOT"

### 1. Docker daemon check
sleep_and_echo "üîç Checking if Docker is running..."
docker info > /dev/null 2>&1 || log_and_fail "Docker is not running. Start Docker Desktop and rerun this script."
echo "‚úÖ Docker is up."

### 2. Clean macOS metadata (._* files)
sleep_and_echo "üßπ Scanning for macOS metadata files (._*)..."
if find . -type f -name '._*' | grep -q .; then
  find . -type f -name '._*' -delete
  echo "‚úÖ Cleaned macOS metadata files."
else
  echo "‚úÖ No macOS metadata files found."
fi

### 3. Stop and clean up containers
sleep_and_echo "‚ôªÔ∏è  Tearing down existing containers (if any)..."
docker compose down --volumes --remove-orphans > /dev/null 2>&1 || true
echo "‚úÖ Cleanup complete."

### 4. Build Docker images
sleep_and_echo "üî® Building Docker images..."
docker compose build --no-cache > "$TEMP_LOG" 2>&1 || log_and_fail "Build failed. Check Dockerfile paths, permissions, or missing dependencies."

echo "üîé Build output summary:"
grep "Built" "$TEMP_LOG" | sed 's/^/ ‚úî /' || echo "(no build summary found)"
echo "‚úÖ Build complete."

### 5. Start containers
sleep_and_echo "üöÄ Starting containers..."
docker compose up -d >> "$TEMP_LOG" 2>&1 || log_and_fail "Container startup failed. See logs with: docker compose logs --tail=50"

echo "üîé Container status:"
docker compose ps --status=running || echo "‚ö†Ô∏è Some services may not have started properly."
echo "‚úÖ Containers are running."

sleep_and_echo "üéâ Kafka testing stack is up and ready to use."

# Optional: Delete log if build and startup succeed fully
rm -f "$TEMP_LOG"-e \n\n===== ./init-alias.sh =====\n
#!/bin/bash

set -euo pipefail

# Config
PROJECT_DIR="/Volumes/DevXLab/Dev/kafka-testing"
SCRIPT_PATH="$PROJECT_DIR/run-kafka-testing.sh"
ALIAS_NAME="prov-kafka-test-env"
ALIAS_COMMAND="alias $ALIAS_NAME='$SCRIPT_PATH'"
CLEAN_ALIAS_NAME="clean"
CLEAN_SCRIPT="$PROJECT_DIR/clean-project.sh"
CLEAN_COMMAND="alias $CLEAN_ALIAS_NAME='bash $CLEAN_SCRIPT'"
BROADCAST_SCRIPT="$PROJECT_DIR/broadcast-test-msgs.sh"
BROADCAST_ALIAS_NAME="sendmsg"
BROADCAST_COMMAND="alias $BROADCAST_ALIAS_NAME='bash $BROADCAST_SCRIPT'"

ZSHRC="$HOME/.zshrc"
BASHRC="$HOME/.bashrc"

# Remove invalid or legacy aliases
clean_old_aliases() {
  local rc_file="$1"
  if grep -qE "alias +(prov[ -]kafka[ -]test[ -]env)=" "$rc_file"; then
    echo "‚ö†Ô∏è Found legacy or invalid alias in $rc_file. Cleaning it up."
    sed -i.bak '/alias \\(prov[ -]kafka[ -]test[ -]env\\)=/d' "$rc_file"
    echo "‚úÖ Cleaned invalid alias from $rc_file."
  fi
}

# Add alias only if it's not already present
add_alias_if_missing() {
  local rc_file="$1"
  [ -f "$rc_file" ] || touch "$rc_file"
  local added_any=false

  clean_old_aliases "$rc_file"

  if ! grep -Fxq "$ALIAS_COMMAND" "$rc_file"; then
    echo "$ALIAS_COMMAND" >> "$rc_file"
    echo "‚úÖ Alias added to $rc_file for $ALIAS_NAME"
    added_any=true
  else
    echo "‚úÖ Alias already present in $rc_file for $ALIAS_NAME"
  fi

  if ! grep -Fxq "$CLEAN_COMMAND" "$rc_file"; then
    echo "$CLEAN_COMMAND" >> "$rc_file"
    echo "‚úÖ Alias added to $rc_file for $CLEAN_ALIAS_NAME"
    added_any=true
  else
    echo "‚úÖ Alias already present in $rc_file for $CLEAN_ALIAS_NAME"
  fi

  if ! grep -Fxq "$BROADCAST_COMMAND" "$rc_file"; then
    echo "$BROADCAST_COMMAND" >> "$rc_file"
    echo "‚úÖ Alias added to $rc_file for $BROADCAST_ALIAS_NAME"
    added_any=true
  else
    echo "‚úÖ Alias already present in $rc_file for $BROADCAST_ALIAS_NAME"
  fi

  if [ "$added_any" = true ]; then
    echo "üîÅ Attempting to source ~/.zshrc and ~/.bashrc in their respective shells..."

echo "‚öôÔ∏è  Spawning zsh to source ~/.zshrc..."
zsh -c "source ~/.zshrc && echo '‚úÖ Sourced ~/.zshrc in zsh'" || echo "‚ö†Ô∏è Failed to source ~/.zshrc in zsh"

    echo "‚öôÔ∏è  Spawning bash to source ~/.bashrc..."
    bash -c "source ~/.bashrc && echo '‚úÖ Sourced ~/.bashrc in bash'" || echo "‚ö†Ô∏è Failed to source ~/.bashrc in bash"

    echo "üí° You may still need to run 'source ~/.zshrc' or 'source ~/.bashrc' manually in your active shell."
  fi
}

echo "üîß Setting up aliases for Kafka testing environment..."

# Ensure main script is executable
if [[ -f "$SCRIPT_PATH" ]]; then
  chmod +x "$SCRIPT_PATH" 2>/dev/null || echo "‚ö†Ô∏è Could not chmod $SCRIPT_PATH (already executable or permission issue)"
else
  echo "‚ùå $SCRIPT_PATH not found. Please check the path and try again."
  exit 1
fi

# Ensure clean script is executable
if [[ -f "$CLEAN_SCRIPT" ]]; then
  chmod +x "$CLEAN_SCRIPT" 2>/dev/null || echo "‚ö†Ô∏è Could not chmod $CLEAN_SCRIPT (already executable or permission issue)"
else
  echo "‚ùå $CLEAN_SCRIPT not found. Please create it before continuing."
  exit 1
fi

# Ensure broadcast message script is executable
if [[ -f "$BROADCAST_SCRIPT" ]]; then
  chmod +x "$BROADCAST_SCRIPT" 2>/dev/null || echo "‚ö†Ô∏è Could not chmod $BROADCAST_SCRIPT (already executable or permission issue)"
else
  echo "‚ùå $BROADCAST_SCRIPT not found. Please create it before continuing."
  exit 1
fi

add_alias_if_missing "$ZSHRC"
add_alias_if_missing "$BASHRC"

echo "üéâ Alias setup attempted."
echo "   ‚ûú If you see warnings, try running: source ~/.zshrc OR source ~/.bashrc manually."
echo "   ‚ûú Once sourced, you can use: $ALIAS_NAME, $CLEAN_ALIAS_NAME, or $BROADCAST_ALIAS_NAME"

# Prompt to run
read -rp "ü§ñ Do you want to run '$SCRIPT_PATH' now? (y/n): " RUN_NOW
RUN_NOW=$(echo "$RUN_NOW" | tr '[:upper:]' '[:lower:]')

if [[ "$RUN_NOW" == "y" ]]; then
  echo -e "\nüöÄ Running '$SCRIPT_PATH'..."
  bash -c "$SCRIPT_PATH"
else
  echo "üìù You can run it later by typing the full path or using the alias if available."
fi-e \n\n===== ./README.md =====\n
# Kafka Messaging Test Environment

This project provisions a portable, containerized Kafka test environment with two messaging clients (`vm1-app`, `vm2-app`) and a central broker handler (`vm3-app`). Each app is deployed in an Alpine-based container and communicates via a Kafka topic named `global.chat`.

---

## üß∞ Requirements

* Docker Desktop (or Docker Engine)
* macOS or Linux (Tested on macOS with zsh)

---

## üöÄ Getting Started

### Step 1: Clean Rebuild

Ensure you are in the project root directory. Then run:

```bash
./clean-rebuild.sh
```

This tears down and fully rebuilds all containers, removes metadata files, and starts up the Kafka infrastructure.

### Step 2: Run Kafka Testing Script

Start the testing environment interactively:

```bash
./run-kafka-testing.sh
```

* This script detects whether it‚Äôs a fresh deployment
* Waits for `vm3-app` to report Kafka readiness
* Optionally restarts `vm1-app` and `vm2-app` and sends messages
* Prompts for log harvesting afterward

### Step 3: View Messages (Optional)

SSH into `vm3-app` and consume messages:

```bash
docker exec -it kafka-testing-vm3-app sh
kafka-console-consumer --bootstrap-server kafka:9092 --topic global.chat --from-beginning
```

---

## üß™ Broadcast Test Messages

To re-broadcast from both vm1 and vm2 manually:

```bash
./broadcast-test-msgs.sh
```

Each container will send a structured greeting message to `global.chat`.

---

## üì¶ Log Harvesting

Harvest logs and optionally copy them to clipboard:

```bash
./harvest-logs.sh         # Just prints categorized logs
./harvest-logs.sh --copy  # Prints and copies logs
```

---

## üßº Clean Project Metadata

To remove macOS-specific metadata, container state, and logs:

```bash
./clean-project.sh
```

---

## üí° Aliases (Optional)

To enable convenience aliases like:

* `prov-kafka-test-env`
* `clean`
* `sendmsg`

Run:

```bash
./alias-kafka-workflow.sh
```

Then source your shell config:

```bash
source ~/.zshrc
```

---

## üìÅ Directory Structure

```
kafka-testing/
‚îú‚îÄ‚îÄ vm1-app/
‚îÇ   ‚îî‚îÄ‚îÄ send-msg.sh
‚îú‚îÄ‚îÄ vm2-app/
‚îÇ   ‚îî‚îÄ‚îÄ send-msg.sh
‚îú‚îÄ‚îÄ vm3-app/
‚îÇ   ‚îî‚îÄ‚îÄ logs/, audit/
‚îú‚îÄ‚îÄ run-kafka-testing.sh
‚îú‚îÄ‚îÄ broadcast-test-msgs.sh
‚îú‚îÄ‚îÄ harvest-logs.sh
‚îú‚îÄ‚îÄ clean-project.sh
‚îú‚îÄ‚îÄ clean-rebuild.sh
‚îú‚îÄ‚îÄ alias-kafka-workflow.sh
‚îî‚îÄ‚îÄ docker-compose.yml
```

---

## ‚úÖ Outcome

Upon successful setup, `vm1-app` and `vm2-app` will send structured greetings to the Kafka topic `global.chat`, and `vm3-app` will act as both the broker manager and log harvester.

---

For questions or contributions, feel free to fork or reach out!-e \n\n===== ./docker-compose.yml =====\n
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.4.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"

  kafka:
    image: confluentinc/cp-kafka:7.4.0
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_AUTO_CREATE_TOPICS_ENABLE: "false"  # <-- üîí LOCKED
      
  vm1-app:
    build:
      context: ./vm1-app
    container_name: kafka-testing-vm1-app
    volumes:
      - vm1-logs:/app/logs

  vm2-app:
    build:
      context: ./vm2-app
    container_name: kafka-testing-vm2-app
    volumes:
      - vm2-logs:/app/logs

  vm3-app:
    build:
      context: ./vm3-app
    container_name: kafka-testing-vm3-app
    volumes:
      - vm3-audit:/app/audit
    healthcheck:
      test: ["CMD", "bash", "-c", "./broker-handler.sh --healthcheck"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 5s

volumes:
  vm1-logs:
  vm2-logs:
  vm3-audit:-e \n\n===== ./vm3-app/broker-handler.sh =====\n
#!/bin/sh
set -euo pipefail

DEFAULT_TOPIC="global.chat"
KAFKA_HOST="kafka"
KAFKA_PORT="9092"

# Healthcheck hook
if [[ "${1:-}" == "--healthcheck" ]]; then
  echo "Kafka broker handler ready"
  exit 0
fi

AUDIT_ROOT="./audit"
USER_ID="user_$(date +%s)"
SESSION_ID="session_$(date +%s)"
AUDIT_DIR="$AUDIT_ROOT/$USER_ID/$SESSION_ID"
mkdir -p "$AUDIT_DIR"

echo "üì° Kafka broker handler is active."
echo "üìÇ Session logs will be stored in: $AUDIT_DIR"
echo "üßµ Ensuring Kafka topic '$DEFAULT_TOPIC' exists..."

kafka-topics --bootstrap-server "$KAFKA_HOST:$KAFKA_PORT" \
  --create --if-not-exists \
  --topic "$DEFAULT_TOPIC" \
  --partitions 1 \
  --replication-factor 1 || true

# Start consumer with live logging
SESSION_LOG="$AUDIT_DIR/transmission.log"
echo "üõ∏ Subscribed to '$DEFAULT_TOPIC'. Logging to $SESSION_LOG..."

kafka-console-consumer \
  --bootstrap-server "$KAFKA_HOST:$KAFKA_PORT" \
  --topic "$DEFAULT_TOPIC" \
  --from-beginning \
  | tee -a "$SESSION_LOG"-e \n\n===== ./vm3-app/connect-to-broker.sh =====\n
#!/bin/sh
set -euo pipefail

# Healthcheck hook
if [[ "${1:-}" == "--healthcheck" ]]; then
  echo "Kafka broker handler ready"
  exit 0
fi

# Audit root setup (ensure ./audit exists)
AUDIT_ROOT="./audit"
mkdir -p "$AUDIT_ROOT"

# User-specific session directory
USER_ID="user_$(date +%s)"
AUDIT_DIR="$AUDIT_ROOT/$USER_ID"
mkdir -p "$AUDIT_DIR"

echo "üì° Kafka broker handler is active."
echo "üìÇ Session logs will be stored in: $AUDIT_DIR"

# Keep process alive
tail -f /dev/null-e \n\n===== ./vm3-app/join-chat.sh =====\n
#!/bin/sh
set -euo pipefail

echo -e "\nüí¨ Kafka Messaging Interface"
echo "Type your message and press Enter."
echo "To exit, type 'exit', '/exit', or just press Ctrl+C."

USER_ID="user_$(hostname)"
LOG_DIR="./audit/$USER_ID"
LOG_FILE="$LOG_DIR/session_$(date +%s).log"
mkdir -p "$LOG_DIR"

while true; do
  read -rp "üìù Message > " input || break
  input=$(echo "$input" | xargs) # Trim whitespace
  case "$input" in
    exit|/exit)
      echo "üëã Exiting chat."
      break
      ;;
    *)
      echo "$(date): $USER_ID said: $input" | tee -a "$LOG_FILE"
      ;;
  esac
done-e \n\n===== ./vm3-app/Dockerfile =====\n
FROM confluentinc/cp-kafka:7.4.0
WORKDIR /app

# Copy scripts as root and fix permissions
USER root
COPY connect-to-broker.sh broker-handler.sh join-chat.sh ./
RUN chmod +x connect-to-broker.sh broker-handler.sh join-chat.sh

# Optionally: ensure audit dir is writable
RUN mkdir -p /app/audit && chmod -R 777 /app/audit

# Stay as root to avoid permission issues with mounted volumes
# (Safer unless you set up a dedicated user and manage volume ownership)
USER root

# Healthcheck and default command
HEALTHCHECK --interval=10s --timeout=3s --start-period=5s CMD ["bash", "-c", "./broker-handler.sh --healthcheck"]
CMD ["bash", "broker-handler.sh"]-e \n\n===== ./vm1-app/Dockerfile =====\n
FROM eclipse-temurin:17-jdk-alpine
WORKDIR /app

# Set Kafka version environment variables
ENV KAFKA_VERSION=3.5.1
ENV SCALA_VERSION=2.13

# Install required tools and Kafka CLI
RUN apk add --no-cache curl tar bash && \
    curl -fsSL "https://archive.apache.org/dist/kafka/${KAFKA_VERSION}/kafka_${SCALA_VERSION}-${KAFKA_VERSION}.tgz" -o kafka.tgz && \
    tar -xzf kafka.tgz -C /opt && \
    rm kafka.tgz && \
    ln -s "/opt/kafka_${SCALA_VERSION}-${KAFKA_VERSION}" /opt/kafka && \
    ln -s /opt/kafka/bin/kafka-console-producer.sh /usr/bin/kafka-console-producer && \
    ln -s /opt/kafka/bin/kafka-run-class.sh /usr/bin/kafka-run-class && \
    chmod +x /usr/bin/kafka-console-producer /usr/bin/kafka-run-class && \
    [ -x /usr/bin/kafka-console-producer ] || (echo "‚ùå kafka-console-producer not installed correctly" && exit 1)

# Kafka tools available in PATH
ENV PATH="/opt/kafka/bin:$PATH"

# Copy app artifacts
COPY target/*-jar-with-dependencies.jar app.jar
COPY send-msg.sh .
RUN chmod +x send-msg.sh

# Keep the container alive for exec/debug
CMD ["tail", "-f", "/dev/null"]-e \n\n===== ./vm1-app/send-msg.sh =====\n
#!/bin/sh
set -euo pipefail

# Just use the tool name ‚Äî don't hardcode full path
KAFKA_CLI="kafka-console-producer.sh"

# Verify it's available
if ! command -v "$KAFKA_CLI" >/dev/null 2>&1; then
  echo "‚ùå $KAFKA_CLI not found in PATH"
  exit 1
fi

# Detect environment
VM_ID=$(hostname)
USER_ID="user_$VM_ID"
TOPIC="global.chat"
MESSAGE="Hello, I am $USER_ID, from $VM_ID!"

# Send message using kafka-console-producer
echo "$MESSAGE" | "$KAFKA_CLI" \
  --bootstrap-server kafka:9092 \
  --topic "$TOPIC" > /dev/null

echo "üì® Sent greeting: \"$MESSAGE\" to topic: $TOPIC"-e \n\n===== ./vm2-app/Dockerfile =====\n
FROM eclipse-temurin:17-jdk-alpine
WORKDIR /app

# Set Kafka version environment variables
ENV KAFKA_VERSION=3.5.1
ENV SCALA_VERSION=2.13

# Install required tools and Kafka CLI
RUN apk add --no-cache curl tar bash && \
    curl -fsSL "https://archive.apache.org/dist/kafka/${KAFKA_VERSION}/kafka_${SCALA_VERSION}-${KAFKA_VERSION}.tgz" -o kafka.tgz && \
    tar -xzf kafka.tgz -C /opt && \
    rm kafka.tgz && \
    ln -s "/opt/kafka_${SCALA_VERSION}-${KAFKA_VERSION}" /opt/kafka && \
    ln -s /opt/kafka/bin/kafka-console-producer.sh /usr/bin/kafka-console-producer && \
    ln -s /opt/kafka/bin/kafka-run-class.sh /usr/bin/kafka-run-class && \
    chmod +x /usr/bin/kafka-console-producer /usr/bin/kafka-run-class && \
    [ -x /usr/bin/kafka-console-producer ] || (echo "‚ùå kafka-console-producer not installed correctly" && exit 1)

# Kafka tools available in PATH
ENV PATH="/opt/kafka/bin:$PATH"

# Copy app artifacts
COPY target/*-jar-with-dependencies.jar app.jar
COPY send-msg.sh .
RUN chmod +x send-msg.sh

# Keep the container alive for exec/debug
CMD ["tail", "-f", "/dev/null"]-e \n\n===== ./vm2-app/send-msg.sh =====\n
#!/bin/sh
set -euo pipefail

# Just use the tool name ‚Äî don't hardcode full path
KAFKA_CLI="kafka-console-producer.sh"

# Verify it's available
if ! command -v "$KAFKA_CLI" >/dev/null 2>&1; then
  echo "‚ùå $KAFKA_CLI not found in PATH"
  exit 1
fi

# Detect environment
VM_ID=$(hostname)
USER_ID="user_$VM_ID"
TOPIC="global.chat"
MESSAGE="Hello, I am $USER_ID, from $VM_ID!"

# Send message using kafka-console-producer
echo "$MESSAGE" | "$KAFKA_CLI" \
  --bootstrap-server kafka:9092 \
  --topic "$TOPIC" > /dev/null

echo "üì® Sent greeting: \"$MESSAGE\" to topic: $TOPIC"-e \n\n===== ./prime-infra.sh =====\n
#!/bin/bash

set -euo pipefail

# Config
PROJECT_DIR="/Volumes/DevXLab/Dev/kafka-testing"
SCRIPT_PATH="$PROJECT_DIR/run-kafka-testing.sh"
ALIAS_NAME="prov-kafka-test-env"
ALIAS_COMMAND="alias $ALIAS_NAME='$SCRIPT_PATH'"
CLEAN_ALIAS_NAME="clean"
CLEAN_SCRIPT="$PROJECT_DIR/clean-project.sh"
CLEAN_COMMAND="alias $CLEAN_ALIAS_NAME='bash $CLEAN_SCRIPT'"

ZSHRC="$HOME/.zshrc"
BASHRC="$HOME/.bashrc"

# Add alias only if it's not already present
add_alias_if_missing() {
  local rc_file="$1"
  [ -f "$rc_file" ] || touch "$rc_file"

  if ! grep -Fxq "$ALIAS_COMMAND" "$rc_file"; then
    echo "$ALIAS_COMMAND" >> "$rc_file"
    echo "‚úÖ Alias added to $rc_file for $ALIAS_NAME"
  else
    echo "‚úÖ Alias already present in $rc_file for $ALIAS_NAME"
  fi

  if ! grep -Fxq "$CLEAN_COMMAND" "$rc_file"; then
    echo "$CLEAN_COMMAND" >> "$rc_file"
    echo "‚úÖ Alias added to $rc_file for $CLEAN_ALIAS_NAME"
  else
    echo "‚úÖ Alias already present in $rc_file for $CLEAN_ALIAS_NAME"
  fi
}

echo "üîß Setting up aliases for Kafka testing environment..."

# Ensure main script is executable
if [[ -f "$SCRIPT_PATH" ]]; then
  chmod +x "$SCRIPT_PATH" 2>/dev/null || echo "‚ö†Ô∏è Could not chmod $SCRIPT_PATH (already executable or permission issue)"
else
  echo "‚ùå $SCRIPT_PATH not found. Please check the path and try again."
  exit 1
fi

# Ensure clean script is executable
if [[ -f "$CLEAN_SCRIPT" ]]; then
  chmod +x "$CLEAN_SCRIPT" 2>/dev/null || echo "‚ö†Ô∏è Could not chmod $CLEAN_SCRIPT (already executable or permission issue)"
else
  echo "‚ùå $CLEAN_SCRIPT not found. Please create it before continuing."
  exit 1
fi

add_alias_if_missing "$ZSHRC"
add_alias_if_missing "$BASHRC"

echo "üéâ Alias setup complete."
echo "   ‚ûú Run: source ~/.zshrc OR source ~/.bashrc"
echo "   ‚ûú Then use: $ALIAS_NAME or $CLEAN_ALIAS_NAME"

# Prompt to run
read -rp "ü§ñ Do you want to run '$ALIAS_NAME' now? (y/n): " RUN_NOW
RUN_NOW=$(echo "$RUN_NOW" | tr '[:upper:]' '[:lower:]')

if [[ "$RUN_NOW" == "y" ]]; then
  echo -e "\nüöÄ Running '$ALIAS_NAME'..."
  bash -c "$SCRIPT_PATH"
else
  echo "üìù You can run it later by typing: $ALIAS_NAME"
fi-e \n\n===== ./run-kafka-testing.sh =====\n
#!/bin/bash
set -euo pipefail

# Prep: resolve directory and clean project metadata
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
bash "$SCRIPT_DIR/clean-project.sh"

cd "$SCRIPT_DIR"

# Deploy logic
if docker ps --format '{{.Names}}' | grep -q kafka-testing-vm3-app; then
  echo "üìà Existing infrastructure detected."
  read -rp "‚ùì Do you want to purge and redeploy everything? (y/n): " resp
  if [[ "$resp" == "y" ]]; then
    echo "‚ôªÔ∏è Rebuilding and redeploying..."
    echo "üßπ Cleaning up persistent log files..."
    rm -f logs/*.log || true

    docker compose down -v --remove-orphans
    docker compose build
    docker compose up -d
  fi
else
  echo "üöÄ First-time setup. Deploying..."
  docker compose build
  docker compose up -d
fi

# Wait for vm3-app to report readiness
echo "‚è≥ Waiting for vm3-app to report readiness..."
MAX_TRIES=30
WAIT_SECS=2
READY_MSG="Kafka broker handler is active."

for ((i = 1; i <= MAX_TRIES; i++)); do
  if docker logs kafka-testing-vm3-app 2>&1 | grep -q "$READY_MSG"; then
    echo "‚úÖ vm3-app is healthy and broker handler is ready."
    break
  fi
  sleep "$WAIT_SECS"
done

if ! docker logs kafka-testing-vm3-app 2>&1 | grep -q "$READY_MSG"; then
  echo "‚ùå Timed out waiting for vm3-app to be ready. Check logs manually."
  exit 1
fi

# Prompt to send messages
read -rp $'üì® Restart vm1/vm2 and send test messages?\n(y/n): ' send_msgs
if [[ "$send_msgs" == "y" ]]; then
  for vm in vm1-app vm2-app; do
    echo "üîÅ Restarting kafka-testing-$vm..."
    docker restart "kafka-testing-$vm" >/dev/null
  done

  echo "üí¨ Broadcasting messages from vm1 and vm2 via broadcast-test-msgs.sh..."
  echo "üìú Function: Sends greeting messages to global.chat topic using kafka-console-producer"
  echo "------------------------------------------------------------"
  bash "$SCRIPT_DIR/broadcast-test-msgs.sh"
  echo "------------------------------------------------------------"
fi

# Prompt to harvest logs
read -rp $'üì¶ Would you like to harvest logs?\n(y/n or y --copy / --help): ' harvest_input
harvest_flag=$(echo "$harvest_input" | awk '{print $1}')
harvest_option=$(echo "$harvest_input" | awk '{print $2}')

case "$harvest_flag" in
  y)
    echo "üì§ Harvesting logs..."
    if [[ "$harvest_option" == "--copy" ]]; then
      bash "$SCRIPT_DIR/harvest-logs.sh" --copy
    else
      bash "$SCRIPT_DIR/harvest-logs.sh"
    fi
    ;;
  --help)
    echo -e "\nüÜò Log Harvesting Help:\n  y          ‚Üí Harvest logs\n  y --copy   ‚Üí Harvest and copy logs to clipboard\n  --help     ‚Üí Show this help message\n"
    ;;
  *)
    echo "‚ùå Invalid input. Use 'y', 'y --copy', or '--help'."
    ;;
esac

exit 0-e \n\n===== ./harvest-logs.sh =====\n
#!/bin/bash
set -euo pipefail

SHOW_HELP=0
COPY_TO_CLIPBOARD=0

for arg in "$@"; do
  case "$arg" in
    --copy) COPY_TO_CLIPBOARD=1 ;;
    --help) SHOW_HELP=1 ;;
  esac
done

if [[ $SHOW_HELP -eq 1 ]]; then
  cat <<EOF
üÜò Usage: ./harvest-logs.sh [--copy] [--help]

  --copy   Copy log summary to clipboard
  --help   Show this help message and exit
EOF
  exit 0
fi

echo "üì¶ Categorizing logs from vm1, vm2, and vm3..."

output=""

extract_logs() {
  local container=$1
  local label=$2
  local logs
  logs=$(docker logs "$container" 2>&1 || echo "N/A")

  if [[ -z "$logs" || "$logs" == "N/A" || "$logs" =~ "No such container" ]]; then
    output+="‚ùå $container has no logs or is unavailable.\n"
    return
  fi

  output+="\nüîç Logs from $container ($label):\n"

  if echo "$logs" | grep -qiE 'ready|active|success|started'; then
    output+="üü¢ [4b] Successful deployment:\n"
    output+="$(echo "$logs" | grep -Ei 'ready|active|success|started')\n"
  fi

  if echo "$logs" | grep -qiE 'warn|debug|info'; then
    output+="üü° [4c] Buggy but live:\n"
    output+="$(echo "$logs" | grep -Ei 'warn|debug')\n"
  fi

  if echo "$logs" | grep -qiE 'error|fail|exception|unhealthy'; then
    output+="üî¥ [4d] Unhealthy logs:\n"
    output+="$(echo "$logs" | grep -Ei 'error|fail|exception|unhealthy')\n"
  fi
}

extract_transmissions() {
  echo "üì° Extracting audit messages from vm3-app..."
  transmission_logs=$(docker exec kafka-testing-vm3-app sh -c "find /app/audit -type f -name 'transmission.log' -exec cat {} +" 2>/dev/null || echo "")

  if [[ -z "$transmission_logs" ]]; then
    output+="\n‚ùå No transmission logs found in vm3.\n"
    return
  fi

  output+="\nüìú [Audit] Messages recorded by vm3:\n"
  output+="$transmission_logs\n"
}

extract_logs kafka-testing-vm1-app "vm1"
extract_logs kafka-testing-vm2-app "vm2"
extract_logs kafka-testing-vm3-app "vm3"
extract_transmissions

echo -e "$output"

if [[ $COPY_TO_CLIPBOARD -eq 1 ]]; then
  echo -e "$output" | pbcopy
  echo "üìã Log summary copied to clipboard."
fi-e \n\n===== ./clean-project.sh =====\n
#!/bin/bash
set -euo pipefail

PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
echo "üßº Cleaning project metadata and artifacts..."

# Delete AppleDouble files (macOS metadata)
find "$PROJECT_DIR" -name '._*' -delete

# Optional: Clean up logs and Docker state
rm -rf "$PROJECT_DIR/logs"/*.log || true
docker compose down -v --remove-orphans || true

# Extra cleanup just in case
rm -f "$PROJECT_DIR"/*/.dockerignore~* || true

echo "‚úÖ Project cleaned successfully."-e \n\n===== ./broadcast-test-msgs.sh =====\n
#!/bin/bash
set -euo pipefail

# Auto-abort if vm1/vm2 containers are not available
if ! docker ps -a --format '{{.Names}}' | grep -Eq '^kafka-testing-vm[1-2]-app$'; then
  echo "‚ùå No target containers (vm1/vm2) found. Make sure the Kafka infra is running."
  exit 1
fi

echo "üìú Function: Sends greeting messages to global.chat topic using kafka-console-producer"
echo "------------------------------------------------------------"

# === Helpers ===

wait_for_running() {
  local cid="$1"
  local name="$2"
  local tries=20
  local delay=1
  for ((i=1; i<=tries; i++)); do
    status=$(docker inspect -f '{{.State.Running}}' "$cid" 2>/dev/null || echo "false")
    if [[ "$status" == "true" ]]; then return 0; fi
    sleep "$delay"
  done
  echo "‚ùå $name container failed to start after ${tries}s"
  return 1
}

find_script_path() {
  local cid="$1"
  docker exec "$cid" sh -c 'find / -type f -name "send-msg.sh" -executable 2>/dev/null | head -n 1'
}

# === Logic ===

found_any=false

for name in vm1-app vm2-app; do
  cid=$(docker ps -aqf "name=$name")
  if [ -z "$cid" ]; then
    echo "‚ùå No container found with name matching '$name'"
    continue
  fi

  # Ensure container is running
  if [[ "$(docker inspect -f '{{.State.Running}}' "$cid")" != "true" ]]; then
    echo "üîÅ Starting container $name ($cid)..."
    docker start "$cid" >/dev/null
    wait_for_running "$cid" "$name" || continue
  fi

  # Locate the script dynamically
  script_path=$(find_script_path "$cid")
  if [[ -z "$script_path" ]]; then
    echo "‚ùå send-msg.sh not found or not executable in $name container"
    continue
  fi

  # Run it
  echo "üì® Sending message from container $cid ($name) via $script_path..."
  if docker exec -i "$cid" sh "$script_path"; then
    found_any=true
  else
    echo "‚ö†Ô∏è Failed to send from container ($name)"
  fi
done

echo "------------------------------------------------------------"

if [[ "$found_any" != "true" ]]; then
  echo "‚ùå No messages sent. Check if send-msg.sh exists and is executable inside containers."
  exit 1
else
  echo "‚úÖ Finished sending messages from all applicable containers."
fi-e \n\n===== ./clean-rebuild.sh =====\n
#!/bin/bash
set -euo pipefail

echo "üßπ Cleaning up Docker environment and macOS metadata..."
docker compose down -v --remove-orphans

echo "üóëÔ∏è Removing macOS metadata files (._*)..."
find . -name '._*' -delete

echo "üî® Rebuilding Docker containers from scratch..."
docker compose build --no-cache

echo "üöÄ Bringing up Kafka test infrastructure..."
docker compose up -d

echo "‚úÖ Done. Infra is rebuilding cleanly and starting up."-e \n\n===== ./._README.md =====\n
    Mac OS X            	   2  ∞     ‚                                    ATTRˇˇ˚◊  ‚   ò                     ò     com.apple.provenance  ≠ãWÿ=˝TË                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            This resource fork intentionally left blank                                                                                                                                                                                                                            ˇˇ